<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rematch GK Reaction Test</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Outfit:wght@300;500;700;900&display=swap" rel="stylesheet">
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{background:#0a0a0f;color:#e0e0e0;font-family:'Outfit',sans-serif;height:100vh;overflow:hidden;display:flex;flex-direction:column}
:root{
  --accent:#00e5ff;--purple:#7c4dff;--bg:#0a0a0f;--card:#14141f;
  --border:#1e1e2e;--success:#00e676;--fail:#ff3d71;--warn:#ffab00;
}

#menu{position:fixed;inset:0;background:var(--bg);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;z-index:1000}
#menu h1{font-size:42px;font-weight:900;letter-spacing:-1px;background:linear-gradient(135deg,var(--accent),var(--purple));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
#menu p{color:#888;font-size:14px;max-width:420px;text-align:center;line-height:1.6}
.menu-btn{
  padding:16px 36px;font-size:18px;font-family:'Outfit',sans-serif;font-weight:700;
  border:2px solid var(--border);border-radius:12px;background:var(--card);color:#fff;
  cursor:pointer;transition:all .2s;min-width:280px;
}
.menu-btn:hover{border-color:var(--accent);box-shadow:0 0 24px rgba(0,229,255,.15);transform:translateY(-2px)}
.menu-btn span{color:#888;font-weight:300;font-size:14px;display:block;margin-top:4px}

#gameArea{flex:1;display:flex;position:relative;overflow:hidden}
.side{flex:1;display:flex;align-items:center;justify-content:center;font-size:56px;font-weight:900;font-family:'JetBrains Mono',monospace;opacity:.06;transition:all .15s;user-select:none;letter-spacing:4px}
.side.active{opacity:1;color:#000}
#left.active{background:var(--accent)}
#right.active{background:var(--accent)}

#ball{position:absolute;width:36px;height:36px;border-radius:50%;background:#fff;left:50%;top:0%;transform:translate(-50%,0%);display:none;box-shadow:0 0 20px rgba(255,255,255,.5);z-index:10}

#hud{position:fixed;top:16px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:50;flex-wrap:wrap;justify-content:center;max-width:90vw}
.dot{width:14px;height:14px;border-radius:50%;border:2px solid #333;transition:all .3s}
.dot.success{background:var(--success);border-color:var(--success);box-shadow:0 0 8px var(--success)}
.dot.fail{background:var(--fail);border-color:var(--fail);box-shadow:0 0 8px var(--fail)}
.dot.current{border-color:var(--accent);box-shadow:0 0 8px var(--accent)}

#info{position:fixed;bottom:16px;width:100%;text-align:center;font-size:16px;font-family:'JetBrains Mono',monospace;color:#888;z-index:50;pointer-events:none}

#resultsOverlay{position:fixed;inset:0;background:rgba(10,10,15,.97);z-index:2000;display:none;flex-direction:column;align-items:center;overflow-y:auto;padding:40px 20px}
#resultsOverlay.show{display:flex}
#resultsContent{max-width:720px;width:100%}
.res-title{font-size:36px;font-weight:900;text-align:center;margin-bottom:8px;letter-spacing:-1px}
.res-avg{text-align:center;font-size:20px;color:var(--accent);font-family:'JetBrains Mono',monospace;margin-bottom:32px}

.round-card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:16px 20px;margin-bottom:16px}
.round-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:4px}
.round-num{font-weight:700;font-size:14px;color:#888}
.round-result{font-family:'JetBrains Mono',monospace;font-size:14px;font-weight:700}
.round-result.ok{color:var(--success)}
.round-result.err{color:var(--fail)}

.timeline-wrap{position:relative;height:64px;background:#0d0d18;border-radius:8px;overflow:hidden;border:1px solid #1a1a2a}
.tl-axis{position:absolute;top:50%;left:0;right:0;height:1px;background:#222}
.tl-signal-line{position:absolute;top:0;bottom:0;width:2px;background:rgba(255,255,255,.25);z-index:2}
.tl-label{position:absolute;bottom:2px;font-size:9px;font-family:'JetBrains Mono',monospace;color:#555;z-index:3;transform:translateX(-50%)}
.tl-label.top{bottom:auto;top:2px}
.tl-bar{position:absolute;height:10px;border-radius:3px;z-index:4;opacity:.85;min-width:3px}
.tl-bar.key-a{background:var(--accent)}
.tl-bar.key-d{background:var(--purple)}
.tl-bar.key-w{background:var(--success)}
.tl-marker{position:absolute;width:10px;height:10px;border-radius:50%;top:50%;transform:translate(-50%,-50%);z-index:6}
.tl-marker.signal-mk{background:#fff;box-shadow:0 0 8px #fff}
.tl-marker.space-mk{background:var(--warn);box-shadow:0 0 6px var(--warn)}
.tl-prezone{position:absolute;top:0;bottom:0;background:rgba(255,255,255,.03);z-index:1;border-right:1px dashed rgba(255,255,255,.12)}

.tl-legend{display:flex;gap:16px;margin-top:8px;flex-wrap:wrap}
.tl-legend-item{display:flex;align-items:center;gap:5px;font-size:11px;color:#888;font-family:'JetBrains Mono',monospace}
.tl-legend-item .sw{width:14px;height:6px;border-radius:2px;flex-shrink:0}
.tl-legend-item .sw.circle{width:7px;height:7px;border-radius:50%}

.btn-row{display:flex;flex-direction:column;align-items:center;margin-top:32px;gap:10px;padding-bottom:40px}
.restart-btn{
  padding:16px 48px;font-size:18px;font-family:'Outfit',sans-serif;font-weight:700;
  border:2px solid var(--accent);border-radius:12px;background:transparent;color:var(--accent);
  cursor:pointer;transition:all .2s;
}
.restart-btn:hover{background:var(--accent);color:#000}
.back-btn{
  padding:12px 32px;font-size:14px;font-family:'Outfit',sans-serif;font-weight:500;
  border:1px solid var(--border);border-radius:8px;background:transparent;color:#888;
  cursor:pointer;transition:all .2s;
}
.back-btn:hover{border-color:#888;color:#fff}

/* ===== MODE 3 ===== */
#mode3Area{position:fixed;inset:0;display:none;overflow:hidden;z-index:40}
#mode3Canvas{width:100%;height:100%;display:block}
.sliderRow{
  margin-bottom:16px;
}
.sliderRow label{
  display:flex;
  justify-content:space-between;
  margin-bottom:6px;
  font-size:14px;
  color:#aaa;
}
.sliderRow input{
  width:100%;
}

</style>

</head>
<div id="mode3Settings" style="
position:fixed;inset:0;z-index:1500;
background:rgba(10,10,15,.97);
display:none;align-items:center;justify-content:center;
">
  <div style="
  background:var(--card);
  border:1px solid var(--border);
  border-radius:16px;
  padding:32px;
  width:420px;
  max-width:90vw;
  ">
    <h2 style="font-size:28px;margin-bottom:16px">–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–¥–∞—Ä–æ–≤</h2>

    <div class="sliderRow">
      <label>–ú–∏–º–æ –≤–æ—Ä–æ—Ç: <b><span id="pOut">30</span>%</b></label>
      <input type="range" min="0" max="100" value="30" id="outRange">
    </div>

    <div class="sliderRow">
      <label>–í —Å—Ç–≤–æ—Ä (—É–≥–ª—ã): <b><span id="pSide">50</span>%</b></label>
      <input type="range" min="0" max="100" value="50" id="sideRange">
    </div>

    <div class="sliderRow">
      <label>–ü–æ —Ü–µ–Ω—Ç—Ä—É: <b><span id="pCenter">20</span>%</b></label>
      <input type="range" min="0" max="100" value="20" id="centerRange">
    </div>

    <button class="menu-btn" style="margin-top:20px" id="startMode3">
      –û–ö
      <span>–ó–∞–ø—É—Å—Ç–∏—Ç—å —Ä–µ–∂–∏–º</span>
    </button>
  </div>
</div>

<body>

<div id="menu">
  <button class="menu-btn" id="duelBtn">
  –î—É—ç–ª—å
  <span>–ò–≥—Ä–∞ –ø—Ä–æ—Ç–∏–≤ –¥—Ä—É–≥–∞</span>
</button>
  <h1>GK Reaction Test</h1>
  <p>–ù–∞–∂–º–∏ <b>A</b> –∏–ª–∏ <b>D</b> —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Å—Ç–æ—Ä–æ–Ω—É, –∑–∞—Ç–µ–º <b>SPACE</b> —á—Ç–æ–±—ã –ø—Ä—ã–≥–Ω—É—Ç—å. –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–∞–∂–∞—Ç–æ –¥–æ –∏–ª–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ —Å –ø—Ä—ã–∂–∫–æ–º. –ù–∞ —Ç–∞–π–º–ª–∞–π–Ω–µ –≤–∏–¥–Ω—ã –≤—Å–µ –Ω–∞–∂–∞—Ç–∏—è ‚Äî –≤–∫–ª—é—á–∞—è –¥–æ —Å–∏–≥–Ω–∞–ª–∞.</p>
  <button class="menu-btn" id="mode1">–†–µ–∂–∏–º 1 ‚Äî –°–∏–≥–Ω–∞–ª<span>–°—Ç–æ—Ä–æ–Ω–∞ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç—Å—è</span></button>
  <button class="menu-btn" id="mode2">–†–µ–∂–∏–º 2 ‚Äî –ú—è—á<span>–ú—è—á –ª–µ—Ç–∏—Ç –≤ —É–≥–æ–ª</span></button>
  <button class="menu-btn" id="mode3btn">–†–µ–∂–∏–º 3 ‚Äî –í–æ—Ä–æ—Ç–∞ 3D<span>–ú—è—á –ª–µ—Ç–∏—Ç –Ω–∞ —Ç–µ–±—è ¬∑ 15 —Ä–∞—É–Ω–¥–æ–≤ ¬∑ A/D/W+Space –∏–ª–∏ –Ω–µ –ø—Ä—ã–≥–∞–π</span></button>
</div>

<div id="hud"></div>
<div id="gameArea">
  <div id="left" class="side">A</div>
  <div id="right" class="side">D</div>
  <div id="ball"></div>
</div>
<div id="info"></div>

<div id="mode3Area">
  <canvas id="mode3Canvas"></canvas>
</div>

<div id="resultsOverlay">
  <div id="resultsContent"></div>
</div>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
let mode3Chances = {
  out: 30,
  side: 50,
  center: 20
};

const $=id=>document.getElementById(id);
  // ===== DUEL STATE =====
let peer = null;
let conn = null;
let isHost = false;
let duelRounds = [];
let duelRoundIndex = 0;

let duelResults = {
  me: [],
  enemy: []
};

let duelScore = {
  me: 0,
  enemy: 0
};
let mode=1,attempts=0,maxAttempts=5;
let target=null,signalTime=0;
let waiting=false,recording=false;

let roundStartTime=0;
let firstDir=null,firstDirTime=null;
let spaceTime=null;

let allKeyDowns={};
let allKeySegments=[];
let allSpacePresses=[];

let roundData=[];
let reactions=[];
const tolerance=20;

// Explicit per-round flag: does this round's ball go into goal?
let roundNeedsSpace=false;

function resetGame(){
  attempts = 0;
  roundData = [];
  reactions = [];

  $('hud').innerHTML = '';
  $('info').textContent = '';
  $('resultsOverlay').classList.remove('show');
  $('left').classList.remove('active');
  $('right').classList.remove('active');
  $('ball').style.display = 'none';

  recording = false;
  waiting = false;

  buildHud();
}

function buildHud(){
  let h='';for(let i=0;i<maxAttempts;i++) h+=`<div class="dot" id="dot${i}"></div>`;
  $('hud').innerHTML=h;
}

function startGame(m){
  mode=m;
  maxAttempts = (mode===3) ? 15 : 5;
  $('menu').style.display='none';
  if(mode===3){
    $('gameArea').style.display='none';
    $('mode3Area').style.display='block';
    initMode3Canvas();
  } else {
    $('gameArea').style.display='flex';
    $('mode3Area').style.display='none';
  }
  resetGame();
  startRound();
}

$('mode1').onclick=()=>startGame(1);
$('mode2').onclick=()=>startGame(2);
$('mode3btn').onclick=()=>{
  $('menu').style.display='none';
  $('mode3Settings').style.display='flex';
};
function createDuel(){
  isHost = true;
  peer = new Peer();

  peer.on('open', id => {
    const link = `${location.origin}${location.pathname}?duel=${id}`;

    navigator.clipboard.writeText(link).then(() => {
      alert(
        '–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞ ‚úÖ\n\n' +
        '–ü—Ä–æ—Å—Ç–æ –≤—Å—Ç–∞–≤—å –µ—ë –¥—Ä—É–≥—É (Ctrl + V)\n\n' +
        link
      );
    });
  });

  peer.on('connection', c => {
    conn = c;
    setupDuelConnection();
    startDuelAsHost();
  });
}
  function joinDuel(roomId){
  isHost = false;
  peer = new Peer();

  peer.on('open', () => {
    conn = peer.connect(roomId);
    setupDuelConnection();
  });
}
  function setupDuelConnection(){
  conn.on('data', data => {

    if(data.type === 'init'){
      duelRounds = data.rounds;
      duelRoundIndex = 0;
      startDuelGame();
    }

    if(data.type === 'roundResult'){
      duelResults.enemy[data.round] = data.result;
      checkRoundFinish(data.round);
    }

    if(data.type === 'rematch'){
      resetDuel();
      startDuelGame();
    }

    if(data.type === 'exit'){
      backToMenu();
    }
  });
}
  function generateDuelRounds(){
  const arr = [];
  for(let i=0;i<15;i++){
    arr.push({
      target: getRandomMode3Target(),
      delay: Math.random()*1500 + 600
    });
  }
  return arr;
}
function startDuelAsHost(){
  duelRounds = generateDuelRounds();
  conn.send({
    type: 'init',
    rounds: duelRounds
  });
  startDuelGame();
}
  function startDuelGame(){
  mode = 3;
  maxAttempts = 15;
  attempts = 0;
  duelRoundIndex = 0;
  duelResults = { me: [], enemy: [] };
  duelScore = { me: 0, enemy: 0 };

  $('menu').style.display = 'none';
  $('gameArea').style.display = 'none';
  $('mode3Area').style.display = 'block';

  initMode3Canvas();
  startDuelRound();
}
  function startDuelRound(){
  if(duelRoundIndex >= 15){
    showDuelResults();
    return;
  }

  const r = duelRounds[duelRoundIndex];

  setTimeout(()=>{
  target = r.target;
  signalTime = performance.now();

  // üî• –í–û–¢ –≠–¢–û–ì–û –ù–ï –•–í–ê–¢–ê–õ–û
  recording = true;
  waiting = true;
  m3SpacePressed = false;
  roundNeedsSpace = false;
  firstDir = null;
  spaceTime = null;

  animateBallMode3(target, ()=>{});
}, r.delay);
}
  function checkRoundFinish(i){
    if(!isHost) return;
  const a = duelResults.me[i];
  const b = duelResults.enemy[i];
  if(!a || !b) return;

  if(a.ok && !b.ok) duelScore.me++;
  else if(!a.ok && b.ok) duelScore.enemy++;
  else if(a.ok && b.ok){
    if(a.reactionMs < b.reactionMs) duelScore.me++;
    else if(b.reactionMs < a.reactionMs) duelScore.enemy++;
  }
duelRoundIndex++;
  startDuelRound();
}
  function showDuelResults(){
  $('resultsOverlay').classList.add('show');

  const win =
    duelScore.me > duelScore.enemy ? '–¢—ã –ø–æ–±–µ–¥–∏–ª üéâ' :
    duelScore.enemy > duelScore.me ? '–¢—ã –ø—Ä–æ–∏–≥—Ä–∞–ª üò≠' :
    '–ù–∏—á—å—è ü§ù';

  $('resultsContent').innerHTML = `
    <div class="res-title">${win}</div>
    <div class="res-avg">
      –¢—ã: ${duelScore.me} ¬∑ –î—Ä—É–≥: ${duelScore.enemy}
    </div>
    <div class="btn-row">
      <button class="restart-btn" onclick="duelRematch()">–ò–≥—Ä–∞—Ç—å –µ—â—ë —Ä–∞–∑</button>
      <button class="back-btn" onclick="duelExit()">–í –º–µ–Ω—é</button>
    </div>
  `;
}
  function duelRematch(){
  conn.send({ type:'rematch' });
  resetDuel();
  startDuelGame();
}

function duelExit(){
  if(conn) conn.close();
  if(peer) peer.destroy();
  conn = null;
  peer = null;
  backToMenu();
}

function resetDuel(){
  duelRoundIndex = 0;
  duelResults = { me: [], enemy: [] };
  duelScore = { me: 0, enemy: 0 };
}
  $('duelBtn').onclick = createDuel;
// ===================== MODE 3 ‚Äî 3D CANVAS =====================
// Camera is ABOVE the crossbar, looking DOWN onto the pitch.
// So the top of the screen = closer to camera (wider), bottom = further away (narrower, the goal line on the ground).
// The crossbar is at the TOP (wide), the ground line at the BOTTOM (narrow).
// Think: you're standing behind the goal, looking over the crossbar down at the pitch.
// The ball comes FROM the pitch (bottom/center) and flies TOWARDS the goal (upward on screen).

const M3={canvas:null,ctx:null,W:0,H:0};
// === MODE 3 BACKGROUND IMAGE ===
const stadiumImg = new Image();
stadiumImg.src = 'stadium_bg.png';

function initMode3Canvas(){
  M3.canvas=$('mode3Canvas');
  M3.ctx=M3.canvas.getContext('2d');
  resizeMode3();
  window.removeEventListener('resize',resizeMode3);
  window.addEventListener('resize',resizeMode3);
}

function resizeMode3(){
  const c=M3.canvas;
  c.width=window.innerWidth;
  c.height=window.innerHeight;
  M3.W=c.width;M3.H=c.height;
  drawMode3Scene();
}

function getGoalGeometry(){
  const W=M3.W,H=M3.H;
  const cx=W/2;

  // Goal tilted ~160¬∞ the other way from previous:
  // Crossbar is FAR = high on screen, narrow (near the pitch)
  // Post bases are CLOSE = low on screen, wide (near us)
  // Heavily tilted back ‚Äî almost looking down on it

  const horizonY=H*0.18;

  // Crossbar ‚Äî raised up for 50% taller goal
  const crossbarY=H*0.28;
  const crossbarHalf=W*0.450;

  // Post bases ‚Äî slightly NARROWER than crossbar (5¬∞ outward tilt = posts lean outward from goal center)
  const postBaseY=H*0.84;
  const goalHeight=postBaseY-crossbarY;
  const postBaseHalf=crossbarHalf - Math.tan(5*Math.PI/180)*goalHeight;

  // 3D DEPTH ‚Äî back of the net lies on the ground behind goal
  // The back corners should be DIRECTLY BEHIND the front posts (same X or slightly wider),
  // but further DOWN the screen (behind us on the ground).
  // This makes the side nets go straight back, not sideways.
  const depthY=H*0.18;

  // Back-top corners (behind crossbar ends ‚Äî wider spread)
  const backTL={x:cx-crossbarHalf-W*0.09, y:crossbarY+depthY};
  const backTR={x:cx+crossbarHalf+W*0.09, y:crossbarY+depthY};
  // Back-bottom corners (behind post bases ‚Äî wider spread)  
  const backBL={x:cx-postBaseHalf-W*0.10, y:postBaseY+depthY};
  const backBR={x:cx+postBaseHalf+W*0.10, y:postBaseY+depthY};

  // depthX kept for compatibility
  const depthX=W*0.04;

  return {cx,
    // Front frame: tl/tr = crossbar ends (far, up, narrow), bl/br = post bases (close, down, wide)
    tl:{x:cx-crossbarHalf, y:crossbarY},
    tr:{x:cx+crossbarHalf, y:crossbarY},
    bl:{x:cx-postBaseHalf, y:postBaseY},
    br:{x:cx+postBaseHalf, y:postBaseY},
    backTL, backTR, backBL, backBR,
    crossbarY, postBaseY, crossbarHalf, postBaseHalf,
    goalLineY: postBaseY,
    horizonY, depthX, depthY
  };
}
function showIdleBall(){
  const g = getGoalGeometry();

  idleBall = {
    x: g.cx,
    y: g.horizonY + 20,
    size: 6
  };

  drawMode3Scene(idleBall); 
}
function drawMode3Scene(ballPos,impactDot){
  const ctx=M3.ctx,W=M3.W,H=M3.H;
  const g=getGoalGeometry();
 //=== BACKGROUND IMAGE (STADIUM: SKY + PITCH) ===
if (stadiumImg.complete) {
  const imgW = stadiumImg.width;
  const imgH = stadiumImg.height;

  const scale = Math.max(W / imgW, H / imgH);
  const drawW = imgW * scale;
  const drawH = imgH * scale;

  const x = (W - drawW) / 2;
  const y = (H - drawH) / 2;

  ctx.drawImage(stadiumImg, x, y, drawW, drawH);
} else {
  ctx.fillStyle = '#0b0f1a';
  ctx.fillRect(0, 0, W, H);
}  

/*
  // === NET INSIDE GOAL OPENING ===
  // Dark area behind the goal (the ground under the net)
  ctx.fillStyle='rgba(5,5,12,0.35)';
  ctx.beginPath();
  ctx.moveTo(g.bl.x,g.bl.y);ctx.lineTo(g.br.x,g.br.y);
  ctx.lineTo(g.backBR.x,g.backBR.y);ctx.lineTo(g.backBL.x,g.backBL.y);
  ctx.closePath();ctx.fill();


  ctx.save();
  ctx.beginPath();
  ctx.moveTo(g.tl.x,g.tl.y);ctx.lineTo(g.tr.x,g.tr.y);
  ctx.lineTo(g.br.x,g.br.y);ctx.lineTo(g.bl.x,g.bl.y);
  ctx.closePath();ctx.clip();

  // Dark net background
  const netBg=ctx.createLinearGradient(0,g.crossbarY,0,g.postBaseY);
  netBg.addColorStop(0,'#080810');netBg.addColorStop(1,'#050508');
  ctx.fillStyle=netBg;
  ctx.fillRect(0,g.crossbarY,W,g.postBaseY-g.crossbarY);

  // Net mesh lines
  ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
  const nv=20;
  for(let i=0;i<=nv;i++){
    const t=i/nv;
    const tx=g.tl.x+(g.tr.x-g.tl.x)*t;
    const bx=g.bl.x+(g.br.x-g.bl.x)*t;
    ctx.beginPath();ctx.moveTo(tx,g.crossbarY);ctx.lineTo(bx,g.postBaseY);ctx.stroke();
  }
  const nh=8;
  for(let i=0;i<=nh;i++){
    const t=i/nh;
    const lx=g.tl.x+(g.bl.x-g.tl.x)*t;
    const rx=g.tr.x+(g.br.x-g.tr.x)*t;
    const y=g.crossbarY+(g.postBaseY-g.crossbarY)*t;
    ctx.beginPath();ctx.moveTo(lx,y);ctx.lineTo(rx,y);ctx.stroke();
  }
  ctx.restore();
*/

  // === 3D GOAL STRUCTURE ===
  const pw=Math.max(6,W*0.007);
  ctx.lineCap='round';ctx.lineJoin='round';
/*

  // --- SIDE NETS (between front posts and back posts) ---
  // Left side net
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(g.tl.x,g.tl.y);ctx.lineTo(g.backTL.x,g.backTL.y);
  ctx.lineTo(g.backBL.x,g.backBL.y);ctx.lineTo(g.bl.x,g.bl.y);
  ctx.closePath();ctx.clip();
  ctx.fillStyle='rgba(0,0,0,0.15)';
  ctx.fill();
  // Side net mesh
  ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
  for(let i=0;i<=8;i++){
    const t=i/8;
    const fx=g.tl.x+(g.bl.x-g.tl.x)*t;
    const fy=g.tl.y+(g.bl.y-g.tl.y)*t;
    const bx=g.backTL.x+(g.backBL.x-g.backTL.x)*t;
    const by=g.backTL.y+(g.backBL.y-g.backTL.y)*t;
    ctx.beginPath();ctx.moveTo(fx,fy);ctx.lineTo(bx,by);ctx.stroke();
  }
  for(let i=0;i<=6;i++){
    const t=i/6;
    const lx=g.tl.x+(g.backTL.x-g.tl.x)*t;
    const ly=g.tl.y+(g.backTL.y-g.tl.y)*t;
    const lx2=g.bl.x+(g.backBL.x-g.bl.x)*t;
    const ly2=g.bl.y+(g.backBL.y-g.bl.y)*t;
    ctx.beginPath();ctx.moveTo(lx,ly);ctx.lineTo(lx2,ly2);ctx.stroke();
  }
  ctx.restore();
*/
/*

  // Right side net
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(g.tr.x,g.tr.y);ctx.lineTo(g.backTR.x,g.backTR.y);
  ctx.lineTo(g.backBR.x,g.backBR.y);ctx.lineTo(g.br.x,g.br.y);
  ctx.closePath();ctx.clip();
  ctx.fillStyle='rgba(0,0,0,0.15)';
  ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
  for(let i=0;i<=8;i++){
    const t=i/8;
    const fx=g.tr.x+(g.br.x-g.tr.x)*t;
    const fy=g.tr.y+(g.br.y-g.tr.y)*t;
    const bx=g.backTR.x+(g.backBR.x-g.backTR.x)*t;
    const by=g.backTR.y+(g.backBR.y-g.backTR.y)*t;
    ctx.beginPath();ctx.moveTo(fx,fy);ctx.lineTo(bx,by);ctx.stroke();
  }
  for(let i=0;i<=6;i++){
    const t=i/6;
    const rx=g.tr.x+(g.backTR.x-g.tr.x)*t;
    const ry=g.tr.y+(g.backTR.y-g.tr.y)*t;
    const rx2=g.br.x+(g.backBR.x-g.br.x)*t;
    const ry2=g.br.y+(g.backBR.y-g.br.y)*t;
    ctx.beginPath();ctx.moveTo(rx,ry);ctx.lineTo(rx2,ry2);ctx.stroke();
  }
  ctx.restore();
*/
/*

  // --- TOP NET (between crossbar and back top bar) ---
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(g.tl.x,g.tl.y);ctx.lineTo(g.tr.x,g.tr.y);
  ctx.lineTo(g.backTR.x,g.backTR.y);ctx.lineTo(g.backTL.x,g.backTL.y);
  ctx.closePath();ctx.clip();
  ctx.fillStyle='rgba(0,0,0,0.1)';
  ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
  for(let i=0;i<=16;i++){
    const t=i/16;
    const fx=g.tl.x+(g.tr.x-g.tl.x)*t;
    const bx=g.backTL.x+(g.backTR.x-g.backTL.x)*t;
    ctx.beginPath();ctx.moveTo(fx,g.tl.y);ctx.lineTo(bx,g.backTL.y);ctx.stroke();
  }
  for(let i=0;i<=4;i++){
    const t=i/4;
    const lx=g.tl.x+(g.backTL.x-g.tl.x)*t;
    const rx=g.tr.x+(g.backTR.x-g.tr.x)*t;
    const y=g.tl.y+(g.backTL.y-g.tl.y)*t;
    ctx.beginPath();ctx.moveTo(lx,y);ctx.lineTo(rx,y);ctx.stroke();
  }
  ctx.restore();
*/
/*

  // --- BACK DEPTH BARS (metal frame going backward) ---
  // These are drawn as lighter/thinner bars ‚Äî they're further away
  const dpw=Math.max(4,pw*0.6);
  ctx.strokeStyle='rgba(200,200,210,0.6)';ctx.lineWidth=dpw;
  // Top-left depth bar (crossbar end ‚Üí back)
  ctx.beginPath();ctx.moveTo(g.tl.x,g.tl.y);ctx.lineTo(g.backTL.x,g.backTL.y);ctx.stroke();
  // Top-right depth bar
  ctx.beginPath();ctx.moveTo(g.tr.x,g.tr.y);ctx.lineTo(g.backTR.x,g.backTR.y);ctx.stroke();
  // Back top bar (connecting back corners)
  ctx.strokeStyle='rgba(200,200,210,0.4)';ctx.lineWidth=dpw*0.8;
  ctx.beginPath();ctx.moveTo(g.backTL.x,g.backTL.y);ctx.lineTo(g.backTR.x,g.backTR.y);ctx.stroke();
  // Bottom-left depth bar (post ‚Üí back)
  ctx.strokeStyle='rgba(200,200,210,0.35)';ctx.lineWidth=dpw*0.7;
  ctx.beginPath();ctx.moveTo(g.bl.x,g.bl.y);ctx.lineTo(g.backBL.x,g.backBL.y);ctx.stroke();
  // Bottom-right depth bar
  ctx.beginPath();ctx.moveTo(g.br.x,g.br.y);ctx.lineTo(g.backBR.x,g.backBR.y);ctx.stroke();
*/
/*
  // --- FRONT FRAME (main posts + crossbar, drawn on top) ---
  // Glow
  ctx.save();
  ctx.shadowColor='rgba(255,255,255,0.3)';ctx.shadowBlur=16;
  ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=pw+10;
  ctx.beginPath();
  ctx.moveTo(g.bl.x,g.bl.y);ctx.lineTo(g.tl.x,g.tl.y);
  ctx.lineTo(g.tr.x,g.tr.y);ctx.lineTo(g.br.x,g.br.y);
  ctx.stroke();
  ctx.restore();
*/
/*
  // Solid white front frame
  ctx.strokeStyle='#e8e8e8';ctx.lineWidth=pw;
  ctx.beginPath();ctx.moveTo(g.bl.x,g.bl.y);ctx.lineTo(g.tl.x,g.tl.y);ctx.stroke();
  ctx.beginPath();ctx.moveTo(g.br.x,g.br.y);ctx.lineTo(g.tr.x,g.tr.y);ctx.stroke();
  ctx.lineWidth=pw+2;
  ctx.beginPath();ctx.moveTo(g.tl.x,g.tl.y);ctx.lineTo(g.tr.x,g.tr.y);ctx.stroke();
*/
  // === IMPACT DOT (bright cyan, very visible) ===
  if(impactDot){
    ctx.save();
    ctx.shadowColor='rgba(0,229,255,1)';ctx.shadowBlur=50;
    ctx.fillStyle='rgba(0,229,255,0.4)';
    ctx.beginPath();ctx.arc(impactDot.x,impactDot.y,32,0,Math.PI*2);ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.shadowColor='rgba(0,229,255,0.9)';ctx.shadowBlur=30;
    ctx.fillStyle='rgba(0,229,255,0.85)';
    ctx.beginPath();ctx.arc(impactDot.x,impactDot.y,16,0,Math.PI*2);ctx.fill();
    ctx.restore();

    ctx.fillStyle='#fff';
    ctx.beginPath();ctx.arc(impactDot.x,impactDot.y,7,0,Math.PI*2);ctx.fill();

    ctx.strokeStyle='rgba(0,229,255,0.7)';ctx.lineWidth=3;
    ctx.beginPath();ctx.arc(impactDot.x,impactDot.y,26,0,Math.PI*2);ctx.stroke();

    ctx.strokeStyle='rgba(0,229,255,0.3)';ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(impactDot.x,impactDot.y,38,0,Math.PI*2);ctx.stroke();

    ctx.strokeStyle='rgba(255,255,255,0.6)';ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(impactDot.x-20,impactDot.y);ctx.lineTo(impactDot.x+20,impactDot.y);
    ctx.moveTo(impactDot.x,impactDot.y-20);ctx.lineTo(impactDot.x,impactDot.y+20);
    ctx.stroke();
  }

  // === BALL ===
  if(ballPos){
    const sz=ballPos.size||14;
    ctx.fillStyle='rgba(0,0,0,0.15)';
    ctx.beginPath();ctx.ellipse(ballPos.x,ballPos.y+sz*0.4,sz*0.7,sz*0.2,0,0,Math.PI*2);ctx.fill();
    const bg=ctx.createRadialGradient(ballPos.x-sz*0.25,ballPos.y-sz*0.25,sz*0.1,ballPos.x,ballPos.y,sz);
    bg.addColorStop(0,'#fff');bg.addColorStop(0.6,'#e8e8e8');bg.addColorStop(1,'#aaa');
    ctx.fillStyle=bg;
    ctx.beginPath();ctx.arc(ballPos.x,ballPos.y,sz,0,Math.PI*2);ctx.fill();
    ctx.save();
    ctx.shadowColor='rgba(255,255,255,0.4)';ctx.shadowBlur=18;
    ctx.fillStyle='rgba(255,255,255,0.02)';
    ctx.beginPath();ctx.arc(ballPos.x,ballPos.y,sz,0,Math.PI*2);ctx.fill();
    ctx.restore();
    ctx.strokeStyle='rgba(0,0,0,0.1)';ctx.lineWidth=0.8;
    const ps=sz*0.32;
    ctx.beginPath();
    for(let i=0;i<5;i++){
      const a=(i/5)*Math.PI*2-Math.PI/2;
      const px=ballPos.x+Math.cos(a)*ps;
      const py=ballPos.y+Math.sin(a)*ps;
      if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
    }
    ctx.closePath();ctx.stroke();
  }
}

// Ball targets ‚Äî crossbar at top (far/narrow), post bases at bottom (close/wide)
function getBallTargets(){
  const g=getGoalGeometry();
  const cx=g.cx;

  // INSIDE GOAL (between crossbar top and post bases bottom):
  const goalH=g.postBaseY-g.crossbarY;
  const leftCorner={
    x: g.bl.x + (g.br.x-g.bl.x)*0.08,
    y: g.crossbarY + goalH*0.55
  };
  const rightCorner={
    x: g.br.x - (g.br.x-g.bl.x)*0.08,
    y: g.crossbarY + goalH*0.55
  };
  const center={
    x: cx,
    y: g.crossbarY + goalH*0.45
  };

  // OUTSIDE GOAL:
  // Over crossbar (above goal on the pitch)
  const overTop={
    x: cx + (Math.random()-0.5)*70,
    y: g.crossbarY - 25 - Math.random()*30
  };
  // Left of left post
  const outLeft={
    x: g.bl.x - 35 - Math.random()*50,
    y: g.crossbarY + goalH*(0.2+Math.random()*0.4)
  };
  // Right of right post
  const outRight={
    x: g.br.x + 35 + Math.random()*50,
    y: g.crossbarY + goalH*(0.2+Math.random()*0.4)
  };

  return {leftCorner,rightCorner,center,overTop,outLeft,outRight};
}

function getRandomMode3Target(){
  const r=Math.random()*100;
  const {out,side,center}=mode3Chances;

  if(r<out){
    return ['OUT_TOP','OUT_LEFT','OUT_RIGHT']
      [Math.floor(Math.random()*3)];
  }
  if(r<out+side){
    return Math.random()<0.5?'A':'D';
  }
  return 'W';
}

let m3AnimFrame=null;

function animateBallMode3(targetType,onDone){
  const targets=getBallTargets();
  const g=getGoalGeometry();
  let endPos;
  // Determine if this ball goes INTO the goal
  let thisNeedsSpace=true;

  switch(targetType){
    case 'A':endPos=targets.leftCorner;break;
    case 'D':endPos=targets.rightCorner;break;
    case 'W':endPos=targets.center;break;
    case 'OUT_TOP':endPos=targets.overTop;thisNeedsSpace=false;break;
    case 'OUT_LEFT':endPos=targets.outLeft;thisNeedsSpace=false;break;
    case 'OUT_RIGHT':endPos=targets.outRight;thisNeedsSpace=false;break;
  }

  // Set the per-round flag IMMEDIATELY so keydown handler can read it
  roundNeedsSpace=thisNeedsSpace;

  // Ball starts from far on the pitch (near the horizon), small, and flies
  // DOWN toward the goal. This matches the behind-goalkeeper perspective.
  const startX=g.cx;
  const startY=g.horizonY + 20; // just below horizon ‚Äî far on the pitch
  const startSize=4;
  const endSize=22;
  const duration=700;
  const startT=performance.now();

  // For misses, calculate impact dot position right away so it shows from frame 1
  const showImpact = !thisNeedsSpace;
  const impactPos = showImpact ? {x:endPos.x, y:endPos.y} : null;

  function frame(now){
    let t=(now-startT)/duration;
    if(t>1)t=1;
    const ease=1-Math.pow(1-t,3);
    const x=startX+(endPos.x-startX)*ease;
    const y=startY+(endPos.y-startY)*ease;
    const size=startSize+(endSize-startSize)*ease;

    // Always show impact dot for misses, even while ball is still flying
    drawMode3Scene({x,y,size}, impactPos);

    if(t<1){
      m3AnimFrame=requestAnimationFrame(frame);
    }else{
      if(onDone)onDone();
    }
  }

  m3AnimFrame=requestAnimationFrame(frame);
}

function clearMode3Ball(){
  if(m3AnimFrame)cancelAnimationFrame(m3AnimFrame);
  drawMode3Scene();
}

// ===================== GAME LOGIC =====================

let m3SpacePressed=false;
let m3TimeoutId=null;
let idleBall = null;

function startRound(){
  if(attempts>=maxAttempts){showResults();return}
$('left').classList.remove('active');
$('right').classList.remove('active');
$('ball').style.display = 'none';
$('info').textContent = '';
firstDir = null;
firstDirTime = null;
spaceTime = null;
allKeySegments = [];
allSpacePresses = [];

  // ===== MODE 3 =====
  if(mode===3){
    clearMode3Ball();
    showIdleBall();

    roundStartTime = performance.now();
    recording = true;
    waiting = false;
    m3SpacePressed = false;
    roundNeedsSpace = false;

    const delay = Math.random()*1500 + 600;

    setTimeout(()=>{
      target = getRandomMode3Target();
      signalTime = performance.now();
      waiting = true;

      animateBallMode3(target, ()=>{
        if(!roundNeedsSpace){
          m3TimeoutId = setTimeout(()=>{
            if(waiting){
              waiting = false;
              recording = false;
              finalizeKeys(performance.now());
              evaluateMode3();
            }
          },1200);
        }
      });
    }, delay);

    return;
  }

  // ===== MODE 1 / 2 =====
// reset per round (mode 1 / 2)
roundStartTime = performance.now();
recording = true;
waiting = false;

firstDir = null;
firstDirTime = null;
spaceTime = null;
allKeySegments = [];
allSpacePresses = [];
  const ball = $('ball');
  const delay = Math.random()*1500 + 500;

  setTimeout(()=>{
    target = Math.random()<.5 ? 'A' : 'D';
    signalTime = performance.now();
    waiting = true;

    if(mode===1){
      $(target==='A'?'left':'right').classList.add('active');
    }

    if(mode===2){
      ball.style.display='block';
      ball.style.left='50%';
      ball.style.top='0%';
      ball.style.transition='none';
      ball.style.transform='translate(-50%,0%)';
      requestAnimationFrame(()=>requestAnimationFrame(()=>{
        ball.style.transition='all 0.35s linear';
        ball.style.left=target==='A'?'20%':'80%';
        ball.style.top='80%';
      }));
    }
  }, delay);
}

document.addEventListener('keydown',e=>{
  if(!recording)return;
  if(e.repeat)return;
  const now=performance.now();
  const code=e.code;

  if((code==='KeyA'||code==='KeyD'||(code==='KeyW'&&mode===3))&&!allKeyDowns[code]){
    allKeyDowns[code]=now;
    if(!firstDir&&waiting){
      if(code==='KeyA')firstDir='A';
      else if(code==='KeyD')firstDir='D';
      else if(code==='KeyW')firstDir='W';
      firstDirTime=now;
    }
  }

  if(code==='Space'){
    allSpacePresses.push(now);

    if(mode===3&&waiting){
      spaceTime=now;m3SpacePressed=true;
      if(!firstDir){
        if(allKeyDowns['KeyA']){firstDir='A';firstDirTime=allKeyDowns['KeyA'];}
        else if(allKeyDowns['KeyD']){firstDir='D';firstDirTime=allKeyDowns['KeyD'];}
        else if(allKeyDowns['KeyW']){firstDir='W';firstDirTime=allKeyDowns['KeyW'];}
      }
      waiting=false;recording=false;
      if(m3TimeoutId){clearTimeout(m3TimeoutId);m3TimeoutId=null;}
      finalizeKeys(now);
      evaluateMode3();
      return;
    }

    if(waiting&&!spaceTime&&mode!==3){
      spaceTime=now;
      if(!firstDir){
        if(allKeyDowns['KeyA']){firstDir='A';firstDirTime=allKeyDowns['KeyA'];}
        else if(allKeyDowns['KeyD']){firstDir='D';firstDirTime=allKeyDowns['KeyD'];}
      }
      waiting=false;recording=false;
      finalizeKeys(now);
      evaluate();
    }
  }
});

document.addEventListener('keyup',e=>{
  const now=performance.now();
  const code=e.code;
  if(allKeyDowns[code]){
    allKeySegments.push({code,down:allKeyDowns[code],up:now});
    delete allKeyDowns[code];
  }
});

function finalizeKeys(endTime){
  for(const code of Object.keys(allKeyDowns)){
    allKeySegments.push({code,down:allKeyDowns[code],up:endTime});
  }
  allKeyDowns={};
}

function evaluateMode3(){
  let result,ok=false;
  const reaction=spaceTime?Math.round(spaceTime-signalTime):null;

  // Use roundNeedsSpace ‚Äî set at animation start, reliable
  if(!roundNeedsSpace){
    // Ball went OUTSIDE the goal
    if(m3SpacePressed){
      result='–ú—è—á –º–∏–º–æ ‚Äî –Ω–µ –ø—Ä—ã–≥–∞–π!';
    }else{
      ok=true;
      result='–ú—è—á –º–∏–º–æ ‚Äî –≤–µ—Ä–Ω–æ!';
    }
  }else{
    // Ball went INSIDE the goal ‚Äî need correct direction + space
    if(!m3SpacePressed){
      result='–ù–µ –ø—Ä—ã–≥–Ω—É–ª!';
    }else if(!firstDir){
      result='SPACE –±–µ–∑ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è';
    }else if(spaceTime+tolerance<firstDirTime){
      result='SPACE —Ä–∞–Ω—å—à–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è';
    }else if(firstDir!==target){
      result='–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞';
    }else{
      ok=true;
      if(reaction!==null)reactions.push(reaction);
      result=`${reaction} –º—Å`;
    }
  }

  const dot=$('dot'+attempts);
  if(dot){dot.classList.remove('current');dot.classList.add(ok?'success':'fail')}

  let targetLabel;
  switch(target){
    case 'A':targetLabel='‚Üê –õ–µ–≤—ã–π —É–≥–æ–ª';break;
    case 'D':targetLabel='‚Üí –ü—Ä–∞–≤—ã–π —É–≥–æ–ª';break;
    case 'W':targetLabel='‚Üë –¶–µ–Ω—Ç—Ä –≤–æ—Ä–æ—Ç';break;
    case 'OUT_TOP':targetLabel='‚¨Ü –ù–∞–¥ –≤–æ—Ä–æ—Ç–∞–º–∏';break;
    case 'OUT_LEFT':targetLabel='‚¨Ö –°–ª–µ–≤–∞ –æ—Ç –≤–æ—Ä–æ—Ç';break;
    case 'OUT_RIGHT':targetLabel='‚û° –°–ø—Ä–∞–≤–∞ –æ—Ç –≤–æ—Ä–æ—Ç';break;
  }

  roundData.push({
    attempt:attempts+1,target,firstDir,ok,result,
    reactionMs:ok&&reaction?reaction:null,
    signalRel:signalTime-roundStartTime,
    spaceRel:spaceTime?spaceTime-roundStartTime:null,
    allSpaceRel:allSpacePresses.map(t=>t-roundStartTime),
    segments:allKeySegments.map(s=>({code:s.code,down:s.down-roundStartTime,up:s.up-roundStartTime})),
    targetLabel
  });
if(conn){
  const res = {
    ok,
    reactionMs: ok ? reaction : null
  };

  duelResults.me[duelRoundIndex] = res;

  conn.send({
    type: 'roundResult',
    round: duelRoundIndex,
    result: res
  });

 
}
  attempts++;
  $('info').textContent=(ok?'‚úÖ ':'‚ùå ')+result;
 if(!conn){
  // –æ–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º
  setTimeout(startRound, 900);
}
}

function evaluate(){
  let result,ok=false;
  if(!firstDir){
    result='SPACE –±–µ–∑ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è';
  }else if(spaceTime+tolerance<firstDirTime){
    result='SPACE —Ä–∞–Ω—å—à–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è';
  }else if(firstDir!==target){
    result='–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞';
  }else{
    const reaction=Math.round(spaceTime-signalTime);
    reactions.push(reaction);
    result=`${reaction} –º—Å`;ok=true;
  }

  const dot=$('dot'+attempts);
  if(dot){dot.classList.remove('current');dot.classList.add(ok?'success':'fail')}

  roundData.push({
    attempt:attempts+1,target,firstDir,ok,result,
    reactionMs:ok?Math.round(spaceTime-signalTime):null,
    signalRel:signalTime-roundStartTime,
    spaceRel:spaceTime?spaceTime-roundStartTime:null,
    allSpaceRel:allSpacePresses.map(t=>t-roundStartTime),
    segments:allKeySegments.map(s=>({code:s.code,down:s.down-roundStartTime,up:s.up-roundStartTime}))
  });

  attempts++;
  $('info').textContent=(ok?'‚úÖ ':'‚ùå ')+result;
  setTimeout(startRound,700);
}

function showResults(){
  $('info').textContent='';
  if(mode===3)$('mode3Area').style.display='none';
  $('resultsOverlay').classList.add('show');
  let avg='‚Äî';
  if(reactions.length)avg=Math.round(reactions.reduce((a,b)=>a+b,0)/reactions.length)+' –º—Å';

  let html=`<div class="res-title">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</div><div class="res-avg">–°—Ä–µ–¥–Ω—è—è —Ä–µ–∞–∫—Ü–∏—è: ${avg}</div>`;
  for(const rd of roundData)html+=buildRoundCard(rd);
  html+=`<div class="btn-row">
    <button class="restart-btn" onclick="restartSameMode()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    <button class="back-btn" onclick="backToMenu()">–í –º–µ–Ω—é</button>
  </div>`;
  $('resultsContent').innerHTML=html;
}

function buildRoundCard(rd){
  const sig=rd.signalRel;
  let maxT=sig+200,minT=0;
  for(const s of rd.segments){maxT=Math.max(maxT,s.up);minT=Math.min(minT,s.down);}
  if(rd.spaceRel)maxT=Math.max(maxT,rd.spaceRel);
  for(const t of rd.allSpaceRel)maxT=Math.max(maxT,t);

  const pad=Math.max((maxT-minT)*0.08,30);
  minT-=pad;maxT+=pad;
  const range=maxT-minT;
  const toP=t=>((t-minT)/range*100);

  let inner='';
  const sigP=toP(sig);
  inner+=`<div class="tl-prezone" style="left:0;width:${sigP}%"></div>`;
  inner+=`<div class="tl-signal-line" style="left:${sigP}%"></div>`;
  inner+=`<div class="tl-marker signal-mk" style="left:${sigP}%"></div>`;

  for(const s of rd.segments){
    if(s.code==='KeyA'||s.code==='KeyD'||s.code==='KeyW'){
      const l=toP(s.down),r=toP(s.up);
      const isA=s.code==='KeyA';
      const isW=s.code==='KeyW';
      const cls=isA?'key-a':isW?'key-w':'key-d';
      const yOff=isA?-14:isW?-2:10;
      const w=Math.max(r-l,0.4);
      inner+=`<div class="tl-bar ${cls}" style="left:${l}%;width:${w}%;top:calc(50% + ${yOff}px)"></div>`;
    }
  }
  for(const t of rd.allSpaceRel){
    inner+=`<div class="tl-marker space-mk" style="left:${toP(t)}%"></div>`;
  }

  const nTicks=6;let ticks='';
  for(let i=0;i<=nTicks;i++){
    const t=minT+(range*i/nTicks);
    const rel=Math.round(t-sig);
    const label=(rel>=0?'+':'')+rel;
    ticks+=`<div class="tl-label" style="left:${toP(t)}%">${label}</div>`;
  }
  ticks+=`<div class="tl-label top" style="left:${sigP}%;color:#fff;font-weight:bold">‚ñº —Å–∏–≥–Ω–∞–ª</div>`;
  if(rd.spaceRel!=null){
    ticks+=`<div class="tl-label top" style="left:${toP(rd.spaceRel)}%;color:var(--warn)">SPACE</div>`;
  }

  const resClass=rd.ok?'ok':'err';
  const resText=rd.ok?`‚úÖ ${rd.reactionMs?rd.reactionMs+' –º—Å':'–í–µ—Ä–Ω–æ'}`:`‚ùå ${rd.result}`;
  let targetLabel=rd.targetLabel||(rd.target==='A'?'‚Üê LEFT (A)':'‚Üí RIGHT (D)');
  const showW=mode===3;

  return `<div class="round-card">
    <div class="round-header">
      <span class="round-num">–†–∞—É–Ω–¥ ${rd.attempt} ¬∑ –¶–µ–ª—å: ${targetLabel}</span>
      <span class="round-result ${resClass}">${resText}</span>
    </div>
    <div class="timeline-wrap">
      <div class="tl-axis"></div>
      ${ticks}${inner}
    </div>
    <div class="tl-legend">
      <div class="tl-legend-item"><div class="sw" style="background:var(--accent)"></div>A (–ª–µ–≤–æ)</div>
      <div class="tl-legend-item"><div class="sw" style="background:var(--purple)"></div>D (–ø—Ä–∞–≤–æ)</div>
      ${showW?'<div class="tl-legend-item"><div class="sw" style="background:var(--success)"></div>W (—Ü–µ–Ω—Ç—Ä)</div>':''}
      <div class="tl-legend-item"><div class="sw circle" style="background:var(--warn)"></div>SPACE</div>
      <div class="tl-legend-item"><div class="sw circle" style="background:#fff"></div>–°–∏–≥–Ω–∞–ª</div>
      <div class="tl-legend-item"><div class="sw" style="background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.15)"></div>–î–æ —Å–∏–≥–Ω–∞–ª–∞</div>
    </div>
  </div>`;
}

window.restartSameMode=function(){
  maxAttempts = (mode===3) ? 15 : 5;
  resetGame();
  if(mode===3){
    $('mode3Area').style.display='block';
    $('gameArea').style.display='none';
    initMode3Canvas();
  }
  startRound();
}
window.backToMenu=function(){
  resetGame();
  $('mode3Area').style.display='none';
  $('gameArea').style.display='flex';
  $('menu').style.display='flex';
}
// ===== MODE 3 SETTINGS LOGIC =====
const outR = $('outRange'),
      sideR = $('sideRange'),
      centerR = $('centerRange');

function updatePercents(){
  let o = +outR.value,
      s = +sideR.value,
      c = +centerR.value;

  const sum = o + s + c || 1;

  o = Math.round(o / sum * 100);
  s = Math.round(s / sum * 100);
  c = 100 - o - s;

  $('pOut').textContent = o;
  $('pSide').textContent = s;
  $('pCenter').textContent = c;

  mode3Chances = {
    out: o,
    side: s,
    center: c
  };
}

[outR, sideR, centerR].forEach(r => {
  r.addEventListener('input', updatePercents);
});

updatePercents();

// –ö–Ω–æ–ø–∫–∞ –û–ö ‚Äî —Å—Ç–∞—Ä—Ç —Ä–µ–∂–∏–º–∞ 3
$('startMode3').onclick = () => {
  $('mode3Settings').style.display = 'none';
  startGame(3);
};
const params = new URLSearchParams(location.search);
if(params.has('duel')){
  $('menu').style.display = 'none';
  joinDuel(params.get('duel'));
}
</script>
</body>
</html>
